name: Discord PR Notification

on:
  pull_request_target:
    types: [opened, closed, reopened, edited, synchronize]
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

jobs:
  discord-notify:
    runs-on: ubuntu-latest
    steps:
      - name: Notify Discord
        uses: actions/github-script@v6
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: '1352445288102494358' # ÌîÑÎ°†Ìä∏ÏóîÎìú Ï±ÑÎÑê
          ROLE_ID: '1347541606927962152'    # ÌîÑÎ°†Ìä∏ÏóîÎìú Ïó≠Ìï†
        with:
          script: |
            const https = require('https');
            
            const token = process.env.DISCORD_BOT_TOKEN;
            const channelId = process.env.CHANNEL_ID;
            const roleId = process.env.ROLE_ID;
            
            const pr = context.payload.pull_request || context.payload.issue;
            const isPr = !!pr.pull_request_url || !!pr.html_url.includes('/pull/');
            
            if (!isPr) { console.log('Not a PR event.'); return; }

            const eventName = context.eventName;
            const action = context.payload.action;
            const prUrl = pr.html_url;
            const prTitle = pr.title;
            const sender = context.payload.sender;
            
            let content = '';
            let embeds = [];
            let isNew = false;
            let threadName = `üí¨ ${prTitle.slice(0, 50)}`;

            // 1. PR ÏÉùÏÑ±
            if (eventName === 'pull_request' && (action === 'opened' || action === 'reopened')) {
              isNew = action === 'opened';
              content = `<@&${roleId}>`;
              embeds = [{
                title: action === 'opened' ? `üöÄ ÏÉàÎ°úÏö¥ PR: ${prTitle}` : `üîÑ PR Îã§Ïãú Ïó¥Î¶º: ${prTitle}`,
                url: prUrl,
                description: pr.body ? (pr.body.length > 200 ? pr.body.slice(0, 200) + '...' : pr.body) : '(ÎÇ¥Ïö© ÏóÜÏùå)',
                color: 5763719, // Green
                author: { name: sender.login, icon_url: sender.avatar_url },
                fields: [
                  { name: 'Repository', value: context.repo.repo, inline: true },
                  { name: 'Branch', value: `${pr.head.ref} ‚û°Ô∏è ${pr.base.ref}`, inline: true }
                ],
                timestamp: new Date().toISOString()
              }];
            } 
            // 2. PR Îã´Ìûò/Î≥ëÌï©
            else if (eventName === 'pull_request' && action === 'closed') {
              const merged = context.payload.pull_request.merged;
              embeds = [{
                title: merged ? `‚úÖ PR Î≥ëÌï©Îê®: ${prTitle}` : `‚õî PR Îã´Ìûò: ${prTitle}`,
                url: prUrl,
                color: merged ? 10181046 : 15548997, // Purple or Red
                author: { name: sender.login, icon_url: sender.avatar_url },
                description: merged ? 'ÏΩîÎìúÍ∞Ä Î©îÏù∏ Î∏åÎûúÏπòÏóê Î≥ëÌï©ÎêòÏóàÏäµÎãàÎã§.' : 'Î≥ëÌï©ÎêòÏßÄ ÏïäÍ≥† Îã´ÌòîÏäµÎãàÎã§.',
                footer: { text: merged ? 'Merged' : 'Closed' },
                timestamp: new Date().toISOString()
              }];
            } 
            // 3. Î¶¨Î∑∞ Ï†úÏ∂ú (ÏäπÏù∏/Î≥ÄÍ≤ΩÏöîÏ≤≠/ÏΩîÎ©òÌä∏)
            else if (eventName === 'pull_request_review') {
               const state = context.payload.review.state.toLowerCase();
               const reviewBody = context.payload.review.body || '';
               const bodyText = reviewBody.length > 300 ? reviewBody.slice(0, 300) + '...' : reviewBody;
               const reviewUrl = context.payload.review.html_url;

               if (state === 'approved') {
                 embeds = [{
                    title: `‚úÖ ÏäπÏù∏Îê® (Approved)`,
                    description: bodyText || 'LGTM! üëç',
                    url: reviewUrl,
                    color: 5763719, // Green
                    author: { name: sender.login, icon_url: sender.avatar_url }
                 }];
               } else if (state === 'changes_requested') {
                 embeds = [{
                    title: `‚ö†Ô∏è Î≥ÄÍ≤Ω ÏöîÏ≤≠ (Changes Requested)`,
                    description: bodyText || 'ÏàòÏ†ïÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.',
                    url: reviewUrl,
                    color: 15548997, // Red
                    author: { name: sender.login, icon_url: sender.avatar_url }
                 }];
               } else {
                 embeds = [{
                    description: `üí¨ **ÏΩîÎ©òÌä∏ Îì±Î°ù**\n${bodyText}`,
                    url: reviewUrl,
                    color: 3447003, // Blue
                    author: { name: sender.login, icon_url: sender.avatar_url }
                 }];
               }
            }
            // 4. ÏùºÎ∞ò ÏΩîÎ©òÌä∏ (Issue Comment)
            else if (eventName === 'issue_comment') {
               const commentBody = context.payload.comment.body;
               embeds = [{
                description: `üí¨ **ÏΩîÎ©òÌä∏ Îì±Î°ù**\n${commentBody.length > 300 ? commentBody.slice(0, 300) + '...' : commentBody}`,
                color: 3447003, // Blue
                author: { name: sender.login, icon_url: sender.avatar_url },
                url: context.payload.comment.html_url
               }];
            }
            // 5. Í∏∞ÌÉÄ (ÏàòÏ†ï, ÎèôÍ∏∞Ìôî Îì±)
            else if (eventName === 'pull_request' && action === 'edited') {
               embeds = [{
                description: `‚úèÔ∏è **PR ÎÇ¥Ïö©Ïù¥ ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.**`,
                title: prTitle,
                url: prUrl,
                color: 16776960, // Yellow
                author: { name: sender.login, icon_url: sender.avatar_url }
               }];
            }
            else if (eventName === 'pull_request' && action === 'synchronize') {
               const commitMsg = context.payload.after ? `Commit: ${context.payload.after.slice(0, 7)}` : 'New commits pushed';
               embeds = [{
                description: `üõ†Ô∏è **ÏÉàÎ°úÏö¥ Ïª§Î∞ãÏù¥ Ìë∏ÏãúÎêòÏóàÏäµÎãàÎã§.**\n${commitMsg}`,
                url: prUrl,
                color: 3447003, // Blue
                author: { name: sender.login, icon_url: sender.avatar_url }
               }];
            } 
            else { return; }

            function request(method, path, body) {
              return new Promise((resolve, reject) => {
                const req = https.request({
                  hostname: 'discord.com',
                  path: '/api/v10' + path,
                  method,
                  headers: {
                    'Authorization': `Bot ${token}`,
                    'Content-Type': 'application/json'
                  }
                }, res => {
                  let data = '';
                  res.on('data', c => data += c);
                  res.on('end', () => {
                      try { resolve(JSON.parse(data)); }
                      catch(e) { resolve({}); }
                  });
                });
                req.on('error', reject);
                if (body) req.write(JSON.stringify(body));
                req.end();
              });
            }

            async function main() {
              // 1. ÏÉà PR
              if (isNew) {
                const msg = await request('POST', `/channels/${channelId}/messages`, { content, embeds });
                if (msg.id) {
                    await request('POST', `/channels/${channelId}/messages/${msg.id}/threads`, {
                        name: threadName,
                        auto_archive_duration: 1440
                    });
                }
                return;
              }

              // 2. Í∏∞Ï°¥ PR (Ïä§Î†àÎìú Ï≤òÎ¶¨)
              const messages = await request('GET', `/channels/${channelId}/messages?limit=50`);
              const originalMsg = messages.find(m => 
                m.author.bot && 
                ((m.embeds && m.embeds[0] && m.embeds[0].url === prUrl) || m.content.includes(prUrl))
              );

              if (originalMsg) {
                let threadId = originalMsg.thread ? originalMsg.thread.id : null;

                if (!threadId) {
                   const newThread = await request('POST', `/channels/${channelId}/messages/${originalMsg.id}/threads`, {
                     name: threadName,
                     auto_archive_duration: 1440
                   });
                   if (newThread.id) threadId = newThread.id;
                }

                if (threadId) {
                  await request('POST', `/channels/${threadId}/messages`, { embeds });
                } else {
                  await request('POST', `/channels/${channelId}/messages`, { 
                    embeds, message_reference: { message_id: originalMsg.id } 
                  });
                }
              } else {
                await request('POST', `/channels/${channelId}/messages`, { 
                  content: `[PR Link](${prUrl})`, embeds 
                });
              }
            }

            await main();
